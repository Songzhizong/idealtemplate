# 前端权限控制设计规范

本文档详述了系统前端权限控制的设计方案与实现模式，涵盖**路由级**、**菜单级**及**细粒度组件级**（按钮、表格列、输入框等）的控制策略。

## 1. 核心架构

系统采用 RBAC (Role-Based Access Control) 模型，由 `authStore` (Zustand) 统一管理认证与权限逻辑。

- **类型安全**: 使用 `Permission` 联合类型确保权限标识符在 IDE 中的自动补全。
- **权限校验**: 核心方法为 `hasPermission(permission: Permission | Permission[], mode?: 'AND' | 'OR')`。

为了防止权限标识符拼写错误并提升开发体验，我们在 `src/config/permissions/` 目录中维护权限常量，并根据功能模块进行拆分（如 `users.ts`）。最后在 `src/types/auth.ts` 中统一导出：

```typescript
// src/config/permissions/users.ts
export const USER_PERMISSIONS = {
  USERS_READ: "users:read",
  // ...
} as const;

// src/types/auth.ts
export { PERMISSIONS } from "@/config/permissions";
export type Permission = (typeof PERMISSIONS)[keyof typeof PERMISSIONS] | (string & {});
```

### 3. 路由守卫

使用 TanStack Router 的 `beforeLoad` 钩子。

```typescript
// src/routes/_authenticated.users.tsx
export const Route = createFileRoute("/_authenticated/users")({
  beforeLoad: () => {
    const { hasPermission } = authStore.getState()
    if (!hasPermission(PERMISSIONS.USERS_READ)) {
      throw redirect({
        to: "/errors/403",
      })
    }
  },
  component: UsersPage,
})
```


## 4. 菜单级控制 (Sidebar Filtering)

在 `nav-config.ts` 中配置 `permission` 字段，布局组件会自动过滤。

```typescript
{ title: "用户管理", to: "/users", permission: PERMISSIONS.USERS_READ }
```

## 5. 组件级细粒度控制 (DX 优化)

### 5.1 &lt;PermissionGate /&gt; (声明式包裹)
用于控制任意 UI 块的显隐。

```tsx
<PermissionGate
  permission={[PERMISSIONS.USERS_ADD, PERMISSIONS.USERS_EDIT]}
  mode="OR"
  fallback={<p>无权操作</p>}
>
  <YourComponent />
</PermissionGate>
```

### 5.2 &lt;AuthButton /&gt; (复合按钮)
集成自动禁用逻辑与 Tooltip 提示。

> [!TIP]
> **交互细节**: 当 `Button` 处于 `disabled` 状态时不会触发原生鼠标事件。因此，在实现中我们使用 `<span>` 包裹按钮，以确保 Tooltip 在禁用状态下仍能正常显示。

```tsx
<AuthButton permission={PERMISSIONS.USERS_ADD} tooltipContent="您没有新增用户的权限">
  新增用户
</AuthButton>
```

### 5.3 表格列控制
通过 `useMemo` 结合权限动态生成 `columns` 定义。

```tsx
const columns = useMemo(() => {
  const base = [...];
  if (hasPermission(PERMISSIONS.USERS_VUEW_PHONE)) {
    base.push({ accessorKey: "phone", header: "手机号" });
  }
  return base;
}, [hasPermission]);

## 6. 性能优化策略

### 6.1 核心优化

#### 算法优化: O(1) 权限查找

`authStore` 内部使用 **Set 数据结构** 存储权限,实现 O(1) 时间复杂度的权限查找:

```typescript
// authStore 内部实现
type AuthState = {
  permissions: Permission[]        // 用于持久化
  permissionSet: Set<Permission>   // 用于 O(1) 查找
}

hasPermission: (permission, mode = "OR") => {
  const { permissionSet } = get()
  const required = Array.isArray(permission) ? permission : [permission]
  
  if (mode === "AND") {
    return required.every((p) => permissionSet.has(p))  // O(N)
  }
  return required.some((p) => permissionSet.has(p))     // O(1) ~ O(N)
}
```

**性能提升**: 当用户拥有 100 个权限时,单次查找从 ~50 次数组遍历优化到 1 次哈希查找 (**50x 提升**)。

#### 持久化恢复机制

由于 `Set` 无法序列化为 JSON,我们使用 `onRehydrateStorage` 在页面刷新后重建 Set:

```typescript
persist(
  (set, get) => ({ /* ... */ }),
  {
    onRehydrateStorage: () => (state) => {
      if (state?.permissions) {
        state.permissionSet = new Set(state.permissions)
      }
    },
  }
)
```

### 6.2 React 性能优化

#### ❌ 常见性能陷阱

```typescript
// ❌ 错误: 解构整个 Store,订阅所有状态变化
function MyButton() {
  const { hasPermission } = useAuthStore()
  // 当 token、user、tenantId 等任何状态变化时,组件都会重新渲染!
  return hasPermission("user:edit") ? <Button>编辑</Button> : null
}
```

**问题**: 组件会在 `token` 刷新、`user` 更新、`tenantId` 切换时重新渲染,即使它只需要 `hasPermission` 函数。

#### ✅ 最佳实践

**方式 1: 使用 Selector (推荐)**

```typescript
// ✅ 正确: 仅订阅 hasPermission 函数
function MyButton() {
  const hasPermission = useAuthStore((state) => state.hasPermission)
  return hasPermission("user:edit") ? <Button>编辑</Button> : null
}
```

**方式 2: 使用专用 Hook (最佳)**

```typescript
import { useHasPermission } from "@/lib/use-has-permission"

// ✅ 最佳: 专用 Hook,语义更清晰
function MyButton() {
  const canEdit = useHasPermission("user:edit")
  return canEdit ? <Button>编辑</Button> : null
}

// 批量权限检查
function TableActions() {
  const { canEdit, canDelete, canExport } = usePermissions({
    canEdit: "user:edit",
    canDelete: "user:delete",
    canExport: ["user:export", "admin:all"],
  })
  
  return (
    <>
      {canEdit && <Button>编辑</Button>}
      {canDelete && <Button>删除</Button>}
      {canExport && <Button>导出</Button>}
    </>
  )
}
```

#### 调用 Action 方法

当需要调用 Store 的 action 方法时,使用 `getState()` 避免订阅:

```typescript
// ✅ 正确: 使用 getState() 调用 action
async function handleLogin() {
  const authStore = useAuthStore.getState()
  authStore.setToken(token)
  authStore.setUser(user)
  authStore.setPermissions(permissions)
}
```

### 6.3 性能优化总结

| 场景 | 推荐方式 | 原因 |
|------|---------|------|
| **权限检查** | `useHasPermission(permission)` | 专用 Hook,语义清晰 |
| **单个状态** | `useAuthStore((state) => state.xxx)` | 精确订阅,避免不必要渲染 |
| **调用 action** | `useAuthStore.getState().xxx()` | 不触发订阅 |
| **多个状态** | 多个 Selector | 避免订阅不需要的状态 |

## 7. 高级逻辑说明

- **组合权限**: `hasPermission(['A', 'B'], 'AND')` 要求同时拥有 A 和 B;`'OR'` 模式满足其一即可。
- **初始化延迟**: 受保护路由的渲染会等待用户信息初始化完成,避免因数据未就绪导致的错误重定向。
- **后端同步**: 前端权限码应与后端 Swagger/API 定义保持严格一致。
- **静态管理员**: 通过 `VITE_IS_STATIC_ADMIN` 环境变量可以绕过所有权限检查(用于开发环境)。

## 8. 总结

1. **路由守卫**解决"能不能进"的问题。
2. **菜单过滤**解决"看不看得见"的问题。
3. **组件/按钮控制**解决"能不能点"的问题。
4. **后端鉴权**解决"最终安全性"的问题。
5. **性能优化**解决"大规模应用性能"的问题。

## 9. 相关文件

- [`auth-store.ts`](../src/lib/auth-store.ts) - 核心权限 Store (含 Set 优化)
- [`use-has-permission.ts`](../src/lib/use-has-permission.ts) - 性能优化专用 Hook
- [`permission-guard.tsx`](../src/features/auth/components/permission-guard.tsx) - 声明式权限组件
- [`auth-button.tsx`](../src/components/auth/auth-button.tsx) - 权限按钮组件
- [`权限性能优化.md`](../brain/权限性能优化.md) - 详细性能优化指南

